// Generated by LiveScript 1.2.0
(function(){
  var signals, signalProducer;
  signals = require('../../../signal/signals');
  signalProducer = {};
  describe('Signals', function(){
    afterEach(function(){
      signalProducer.bypassed.removeAll();
      return signalProducer.routed.removeAll();
    });
    specify('should dispatch bypassed if don\'t match any route', function(){
      var count, requests, a;
      count = 0;
      requests = [];
      a = crossroads.addRoute('/{foo}_{bar}');
      a.matched.add(function(foo, bar){
        return expect(null).toEqual('fail: shouldn\'t match');
      });
      crossroads.bypassed.add(function(request){
        requests.push(request);
        return count++;
      });
      crossroads.parse('/lorem/ipsum');
      crossroads.parse('/foo/bar');
      expect(requests[0]).toBe('/lorem/ipsum');
      expect(requests[1]).toBe('/foo/bar');
      return expect(count).toBe(2);
    });
    specify('should dispatch routed at each match', function(){
      var count, requests, count2, routed, first, a;
      count = 0;
      requests = [];
      count2 = 0;
      a = crossroads.addRoute('/{foo}_{bar}');
      a.matched.add(function(foo, bar){
        return count++;
      });
      crossroads.bypassed.add(function(request){
        requests.push(request);
        return count2++;
      });
      crossroads.routed.add(function(request, data){
        var routed, first;
        requests.push(request);
        count++;
        expect(request).toBe('/foo_bar');
        expect(data.route).toBe(a);
        expect(data.params[0]).toEqual('foo');
        expect(data.params[1]).toEqual('bar');
        routed = true;
        return first = data.isFirst;
      });
      crossroads.parse('/lorem/ipsum');
      crossroads.parse('/foo_bar');
      expect(requests[0]).toBe('/lorem/ipsum');
      expect(requests[1]).toBe('/foo_bar');
      expect(count).toBe(2);
      expect(count2).toBe(1);
      expect(routed).toEqual(true);
      return expect(first).toEqual(true);
    });
    return specify('should not dispatch routed/bypassed/matched twice for same request multiple times in a row', function(){
      var bypassed, routed, matched, switched, a;
      bypassed = [];
      routed = [];
      matched = [];
      switched = [];
      a = crossroads.addRoute('/{foo}_{bar}');
      a.matched.add(function(a, b){
        return matched.push(a, b);
      });
      a.switched.add(function(req){
        return switched.push(req);
      });
      crossroads.bypassed.add(function(req){
        return bypassed.push(req);
      });
      crossroads.routed.add(function(req, data){
        routed.push(req);
        return expect(data.route).toBe(a);
      });
      crossroads.parse('/lorem/ipsum');
      crossroads.parse('/foo_bar');
      crossroads.parse('/foo_bar');
      crossroads.parse('/lorem_ipsum');
      crossroads.parse('/dolor');
      crossroads.parse('/dolor');
      crossroads.parse('/lorem_ipsum');
      crossroads.parse('/lorem_ipsum');
      crossroads.parse('/lorem_ipsum');
      expect(routed).toEqual(['/foo_bar', '/lorem_ipsum']);
      expect(bypassed).toEqual(['/lorem/ipsum', '/dolor']);
      expect(switched).toEqual([]);
      return expect(matched).toEqual(['foo', 'bar', 'lorem', 'ipsum']);
    });
  });
}).call(this);
